# 내부 데이터 구조 벤치마크 결과

## 개요

이 벤치마크는 Python의 주요 내부 데이터 구조들의 성능을 비교 분석한 결과입니다.

### 테스트 대상 데이터 구조
- **Python List**: 동적 배열, 순차 접근에 최적화
- **Python Dict**: 해시 테이블, 키-값 저장
- **Python Set**: 해시 기반 집합, 유일성 보장
- **Python Deque**: 양방향 큐, 양끝 삽입/삭제 최적화
- **Python Tuple**: 불변 배열, 메모리 효율적

### 성능 측정 항목
- **Insert**: 요소 하나씩 순차 삽입 시간
- **Delete**: 요소 하나씩 삭제 시간
- **Lookup**: 요소 검색 시간
- **Memory**: 생성 시 최대 메모리 사용량
- **BatchIns**: 배치 삽입 시간
- **BatchDel**: 배치 삭제 시간

## 벤치마크 결과

### 크기 1,000개 요소
```
Structure    Insert(ms) Delete(ms) Lookup(ms) Memory(KB)  BatchIns(ms) BatchDel(ms)
Python List  0.03       0.00       0.02       31.20       0.04         0.03
Python Dict  0.11       0.01       0.00       108.11      0.29         0.12
Python Set   0.02       0.01       0.00       55.55       0.05         0.04
Python Deque 0.02       0.00       0.01       31.86       0.02         0.03
Python Tuple 0.01       0.00       0.03       31.19       0.03         0.00
```

### 크기 5,000개 요소
```
Structure    Insert(ms) Delete(ms) Lookup(ms) Memory(KB)  BatchIns(ms) BatchDel(ms)
Python List  0.09       0.00       0.54       187.45      0.07         0.05
Python Dict  0.37       0.02       0.01       540.33      0.81         0.36
Python Set   0.28       0.04       0.00       785.89      0.25         0.17
Python Deque 0.09       0.00       0.01       189.34      0.05         0.06
Python Tuple 0.03       0.01       0.48       187.44      0.02         0.00
```

### 크기 10,000개 요소
```
Structure    Insert(ms) Delete(ms) Lookup(ms) Memory(KB)  BatchIns(ms) BatchDel(ms)
Python List  0.22       0.00       2.50       382.77      0.08         0.08
Python Dict  0.65       0.03       0.01       1089.59     1.22         0.76
Python Set   0.22       0.05       0.01       816.80      0.12         0.13
Python Deque 0.17       0.00       0.00       385.81      0.08         0.08
Python Tuple 0.06       0.02       2.02       382.75      0.02         0.01
```

## 최적 성능자 분석

### 삽입 성능
- **모든 크기에서 Tuple이 최우수** (불변이므로 한 번에 생성)
- **Deque와 Set이 그 다음** (최적화된 삽입 알고리즘)
- **Dict이 가장 느림** (해시 계산과 충돌 처리 오버헤드)

### 삭제 성능
- **Deque가 대부분 최우수** (양끝 삭제 최적화)
- **Tuple이 빠름** (슬라이싱으로 새 객체 생성)
- **Dict과 Set은 중간** (해시 기반 삭제)

### 검색 성능
- **Set과 Dict이 압도적 우위** (O(1) 해시 기반 검색)
- **List와 Tuple은 느림** (O(n) 선형 검색)
- **Deque는 중간** (구현에 따라 다름)

### 메모리 효율성
- **Tuple이 가장 효율적** (불변 객체, 최소 오버헤드)
- **List와 Deque는 유사** (동적 배열)
- **Dict이 가장 많이 사용** (해시 테이블 오버헤드)
- **Set은 중간** (해시 기반이지만 값만 저장)

## 사용 권장사항

### 🏆 **Tuple 사용 권장**
- 불변 데이터가 필요한 경우
- 메모리 효율성이 중요한 경우
- 한 번 생성 후 변경하지 않는 데이터

### 🚀 **Set 사용 권장**
- 빠른 검색이 필요한 경우
- 중복 제거가 필요한 경우
- 집합 연산(합집합, 교집합 등)이 필요한 경우

### ⚡ **Deque 사용 권장**
- 양끝에서 삽입/삭제가 빈번한 경우
- 큐나 스택 구현 시
- 순차 처리가 주된 용도인 경우

### 📊 **Dict 사용 권장**
- 키-값 매핑이 필요한 경우
- 빠른 키 기반 검색이 필요한 경우
- 메모리 사용량보다 검색 속도가 중요한 경우

### 📝 **List 사용 권장**
- 인덱스 기반 접근이 주된 용도인 경우
- 순서가 중요하고 중간 삽입이 필요한 경우
- 일반적인 순차 데이터 처리

## 성능 특성 요약

| 구조 | 삽입 | 삭제 | 검색 | 메모리 | 특징 |
|------|------|------|------|--------|------|
| List | 보통 | 빠름 | 느림 | 효율적 | 순차 접근, 인덱싱 |
| Dict | 느림 | 보통 | 매우 빠름 | 많음 | 키-값, 해시 기반 |
| Set | 빠름 | 보통 | 매우 빠름 | 보통 | 유일성, 해시 기반 |
| Deque | 빠름 | 매우 빠름 | 보통 | 효율적 | 양방향 큐 |
| Tuple | 매우 빠름 | 빠름 | 느림 | 매우 효율적 | 불변, 메모리 최적화 |

## 코드 사용법

### 벤치마크 실행
```bash
python3 simple_benchmark.py
```

### 커스텀 크기로 테스트
```python
benchmark = SimpleDataStructureBenchmark(sizes=[500, 2000, 8000])
benchmark.run_full_benchmark()
```

---

이 벤치마크는 일반적인 사용 패턴을 기준으로 측정되었으며, 실제 애플리케이션에서는 데이터 패턴과 사용 사례에 따라 결과가 달라질 수 있습니다.